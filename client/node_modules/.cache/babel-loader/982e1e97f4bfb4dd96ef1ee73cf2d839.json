{"ast":null,"code":"/**\r\n * Module dependencies.\r\n */\nvar url = require('./url');\n\nvar parser = require('socket.io-parser');\n\nvar Manager = require('./manager');\n\nvar debug = require('debug')('socket.io-client');\n/**\r\n * Module exports.\r\n */\n\n\nmodule.exports = exports = lookup;\n/**\r\n * Managers cache.\r\n */\n\nvar cache = exports.managers = {};\n/**\r\n * Looks up an existing `Manager` for multiplexing.\r\n * If the user summons:\r\n *\r\n *   `io('http://localhost/a');`\r\n *   `io('http://localhost/b');`\r\n *\r\n * We reuse the existing instance based on same scheme/port/host,\r\n * and we initialize sockets for each namespace.\r\n *\r\n * @api public\r\n */\n\nfunction lookup(uri, opts) {\n  if (typeof uri === 'object') {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n  var parsed = url(uri);\n  var source = parsed.source;\n  var id = parsed.id;\n  var path = parsed.path;\n  var sameNamespace = cache[id] && path in cache[id].nsps;\n  var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;\n  var io;\n\n  if (newConnection) {\n    debug('ignoring socket cache for %s', source);\n    io = Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug('new io instance for %s', source);\n      cache[id] = Manager(source, opts);\n    }\n\n    io = cache[id];\n  }\n\n  if (parsed.query && !opts.query) {\n    opts.query = parsed.query;\n  }\n\n  return io.socket(parsed.path, opts);\n}\n/**\r\n * Protocol version.\r\n *\r\n * @api public\r\n */\n\n\nexports.protocol = parser.protocol;\n/**\r\n * `connect`.\r\n *\r\n * @param {String} uri\r\n * @api public\r\n */\n\nexports.connect = lookup;\n/**\r\n * Expose constructors for standalone build.\r\n *\r\n * @api public\r\n */\n\nexports.Manager = require('./manager');\nexports.Socket = require('./socket');","map":null,"metadata":{},"sourceType":"script"}